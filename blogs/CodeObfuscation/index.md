---
title: "软件与系统安全笔记 - 代码混淆"
date: 2024-06-12
draft: false
description: "软件与系统安全笔记 - 代码混淆"
tags: ["软件与系统安全"]
---
**<u>软件与系统安全笔记 - 代码混淆</u>**



### 代码混淆

代码混淆（Obfuscation）是一种在软件保护领域广泛应用的技术，其主要目的是为了提高程序代码的阅读和理解难度，从而阻碍逆向工程(reverse engineering)的进行。这一技术通过修改源代码、字节码或二进制代码，使代码在功能上保持不变，但其结构、变量名、函数名等被改写得难以理解，增加了非法分析者逆向分析软件以获取其内部逻辑、算法或敏感信息的难度。

**混淆的主要技术手段包括但不限于**：

1. **数据混淆**：对常量、字符串等数据进行加密或编码，运行时再解密使用，使得静态分析中难以直接看到原始数据。
2. **控制流混淆**：通过插入无意义的跳转、条件分支等，改变代码的正常执行流程，但确保最终结果不变，这大大增加了分析的复杂度。

**模型与层次**

- **输入与输出程序的语义等价**：混淆过程必须保证处理后的程序在功能上与原程序完全一致，只是表现形式不同，这是混淆的基本原则。
- **混淆的层次**：
  - **源代码级混淆**：直接对高级编程语言的源代码进行修改。
  - **汇编/二进制级混淆**：在编译后的机器代码层面进行操作，这通常涉及到更底层的指令重写和优化。
  - **中间代码/字节码级混淆**：对于像Java、.NET这类平台，可以在其字节码或中间代码（如Java bytecode, MSIL）上进行混淆，这是较为常见的混淆方式，因为这类代码比源代码更接近机器码，同时仍保留了一定程度的平台独立性和可操作性。



#### **完美混淆器**

对于一个概率算法O，完美混淆器需要满足下面三个条件：

1. **功能性（Functionality）**: 这意味着混淆后的程序`O(P)`必须保持与原程序`P`完全相同的功能。也就是说，对于任何可能的输入`x`，`O(P)(x)`和`P(x)`的结果必须一致。这一条件保证了混淆过程不改变程序的行为，只是改变了其表现形式。
2. **多项式减速（Polynomial Slowdown）**: 混淆后的程序在最坏情况下的运行时间（时间和空间复杂度）相比原程序最多只能是多项式级别的增长。这是为了确保混淆虽然增加了程序的复杂度，但仍然保持了实用性和效率。
3. **虚拟黑盒（Virtual Black-Box, VBB）属性**: 这是最关键也是最具挑战性的条件。它要求即使一个具有强大计算能力的攻击者，拥有混淆程序`O(P)`的完整源代码或二进制代码，并且能够在多项式时间内执行任意复杂的计算，也无法从`O(P)`中学到关于原程序`P`的任何额外信息，除了通过反复执行`O(P)`并观察输出（即所谓的黑盒测试）所能获取的信息。简而言之，混淆后的程序对于攻击者来说就像一个黑盒，尽管他们可以看到盒子内部的每一个细节，但是仍无法理解其工作原理或逆推出原始程序的结构。



#### 数据混淆：常量展开

假设程序在某处使用了一个常量值，可以利用一个计算过程代替这个常量值，而这个计算过程的结果就是这个常量值

比如：x = 4 可以混淆成 x = 2 + 2



#### 数据混淆：数据编码

数据编码是**将原始数据转换成不易识别的编码数据**来增加逆向工程的难度。

假设有一个编码函数f(x)：

- 混淆：将x0 -> f(x0）
- 解混淆：将f(x0) -> x0。

编码函数f必须满足：

- 给定f(x)，无法推测出x
- 给定x和f(x)，无法推测出f

**多项式编码**

多项式编码通过将数据映射到多项式的值上来实现混淆。

f(x) = a_nx^n + ... + a_1x + a_0。

这种方法的优势在于，即使攻击者知道多个 (x,f(x)) 对，直接从多项式系数逆推出原始数据或多项式本身也相对困难，尤其是当多项式的阶数较高时。

**剩余数编码**

剩余数编码基于模运算，先选择几个互质的模m1, m2, ... , mk，然后将原始数据x对这些模分别取余得到 y1 = x mod m1, y2 = x mod m2, ... yk = x mod mk。解码的时候，需要通过中国剩余定理或其他算法利用y1,...yk和m1,...mk求出x。这种方法增加了逆向分析的复杂度，因为攻击者需要处理多个模运算的关系，而非单一的直接转换。

**同态编码**

一般的编码方案在运行前需要动态解码，会引入额外的计算开销，并可能暴露解码逻辑。而同态编码允许直接利用编码后的数据进行计算，而无需先解码再运算。

对于两个群G,H，如果存在一个映射f: G -> H，且对于两个元素x, y属于G，那么f(x),f(y)属于H，那么f如果是个同态映射，就意味着f(x +g y) = f(x) +h f(y)，其中+g是群G中的运算，+h是群H中的运算。

举个例子：

x1和x2，混淆后分别为f(x1)和f(x2)，运行时如果要计算x1*x2，需要先把f(x1)->x1，f(x2)->x2，再进行运算。而同态编码允许运行的时候直接计算f(x1) * f(x2) = f(x1 * x2) -> x1 * x2。种性质使得可以在保护隐私的同时处理数据，特别适用于云计算和数据安全领域。

将同态的概念应用于代码混淆或数据保护时，我们可以构建这样的系统：源代码或数据在某个“未编码域”（原始的、易理解的形式）中定义，对应于代数结构`G`；通过一个同态映射`f`，这些源代码或数据被转换到“编码域”（混淆的、难以解读的形式），对应于另一个代数结构`H`。关键在于，这个映射不仅要保证混淆后的数据在功能上等价于原数据，而且要在`H`中定义一套运算规则，使得对编码后数据的操作结果，经过逆映射后，等同于原数据在`G`中直接操作的结果。

全同态加密就是能进行任意运算，不管加法、乘法乃至更复杂的操作，都满足上面的定义。



#### 数据混淆：基于模式的混淆

基于模式的混淆就是**将简单的、容易理解的指令替换为功能等价但更为复杂的指令**。

举个例子：

-x  ->  ~x+1

在计算机中，对一个数取负数，等价于对这个数取反并加1。

比如整数1，二进制为0001，对0001进行取反并+1后就是1111。而1111代表的就是-1。



#### 控制流混淆：二进制静态分析对控制流的假定

- CALL指令只用于函数调用, 且调用目标即函数的起始地址

- 绝大多数函数调用会返回, 且返回到CALL指令的后一条指令的位 置; RET和RETN代表函数边界

- 遇到条件跳转时, 假定: 分支两侧均可能被执行; 分支两侧均为代码而非数据
- 容易确定间接跳转的目标地址
- 只有switch结构能够生成间接跳转; 只有对函数指针的调用能够 生成间接调用
- 所有控制转移目标地址都是代码而非数据
- 异常以一种可预测的方式使用

控制流混淆旨在通过改变程序的正常控制流程，使得攻击者难以理解和分析程序的行为。

1. **打破CALL指令的直接关联**: 通常，`CALL`指令被假定为仅用于函数调用，并且其目标是函数的起始地址。混淆技术可以插入无意义的`CALL`指令到非函数起始位置，或者使用自定义的跳转指令代替标准的`CALL`，使得分析者难以区分真实函数调用与混淆指令。

2. **扰乱函数返回流**: 通过在函数返回点插入额外的跳转指令，或者使用非标准的返回机制（如返回到非CALL之后的位置），混淆技术可以使程序的返回流程变得难以追踪。此外，还可以使用“花指令”（无意义的指令序列）来混淆函数的退出路径。

3. **复杂化条件跳转**: 改变条件跳转的逻辑，引入看似无关的条件检查，或者使用复杂的计算来决定跳转目标，使分析者难以判断分支行为。同时，也可以将数据区域伪装成可执行代码，让分析工具误以为数据也是潜在的控制流部分。

4. **间接跳转目标的隐蔽化**: 利用动态计算的跳转表、随机化或加密跳转目标地址，使得间接跳转的目的地在静态分析时难以确定。这包括对switch-case结构的混淆和对函数指针调用的隐藏，使得它们的目标不再是显而易见的。

5. **混淆代码与数据边界**: 将代码片段嵌入到数据区域，或将数据块布置得像可执行代码，混淆分析者对内存区域的直观判断。这样，即使是间接跳转，也可能指向看似数据的区域，实际上却执行了代码。

6. **异常处理的混淆**: 通过异常处理机制插入混淆代码，或者将正常的控制流逻辑伪装成异常处理路径，可以进一步模糊程序的实际执行流程。异常的触发和处理方式变得不透明，增加了逆向工程的难度。



#### 控制流混淆：组合使用函数内联与外联

函数内联：**将函数的代码直接复制到调用的地方。**

比如：

```C++
int add(x, y){

 	return x + y;

}

int main(){

  int x = 1; int y = 2;

	int z = add(x, y);

	return 0;

}

### 函数内联 ###
### 直接将add函数的代码块复制到main函数里，变为：###

int main(){

	int x = 1; int y = 2;

	int z = x + y;

  return 0;	

}
```

函数外联：与函数内联相反，**将一部分代码抽离出来单独写个函数，然后将代码块的部分替换为函数的调用。**



#### 控制流混淆：通过跳转破坏局部性

通过跳转的思想是打乱代码的自然执行顺序。

在未经混淆的在未经混淆的程序中，代码通常按照逻辑上的连续性和相关性组织，形成了良好的局部性，便于人类理解和分析。控制流图（CFG，Control Flow Graph）中的基本块（Basic Block）通常紧密相连，代表了直接的执行序列。通过在基本块中不必要地插入无条件跳转（Jump）或goto语句，可以打破这种自然的执行流，使得相邻的语句在执行时可能相隔甚远，或者使得代码执行路径变得错综复杂。

比如，原本连续的几行代码：

```bash
A; // 执行语句A
B; // 执行语句B
C; // 执行语句C
D; // 执行语句D
E; // 执行语句E
F; // 执行语句F
```

在经过跳转混淆后可能会变成：

```bash
A; // 执行语句A
jump to D;
B; // 执行语句B
jump to E;
C; // 执行语句C
jump to F;
D: jump to B;
E: jump to C;
F: // 正常继续执行后续代码
```

这种混淆方法极大地混淆了代码的直观阅读，使得分析者难以直接通过阅读代码逻辑来理解程序的工作方式。



#### 控制流混淆：不透明谓词

不透明谓词就是一种特殊的条件判断语句，但是这个条件判断语句的值只有混淆者知道，对于攻击者而言很难判断这个条件判断语句的值。

**不透明谓词的分类**

- **PT（Always True）**: 这类不透明谓词在编译或混淆阶段已知其值永远为真。将其作为分支条件插入代码中，不会实际改变执行路径，但对于不知情的分析者来说，它会掩盖真实控制流程，让其看起来仿佛有额外的分支选择。
- **PF（Always False）**: 相对于PT，PF类型的不透明谓词在混淆时确定其值总是假。同样，它也被用作条件判断，可以引入看似可能影响控制流但实际上恒不被执行的代码路径。
- **P?（Indeterminate）**: 这类不透明谓词的值在混淆时可能为真也可能为假，但其确定性对于外部分析者来说难以判断。利用P?可以创建更加复杂的混淆效果，使得分析者难以区分哪些分支是真正有意义的，只有混淆者才能知道哪些分支才真正有意义。

**不透明谓词的应用**

1. **增加伪分支**：在程序的关键路径中插入基于不透明谓词的条件分支，可以创建出额外的控制流路径，这些路径要么永远不被执行，要么其执行与否对程序逻辑没有实际影响。这种做法能够显著增加控制流图（CFG）的复杂度，使逆向分析更加困难。
2. **混淆条件逻辑**：在实际的逻辑判断中嵌入不透明谓词，即使这些谓词的值对结果没有影响。例如，一个简单的布尔逻辑`if (condition && PT)`，其中`condition`是真实逻辑判断，而`PT`是始终为真的不透明谓词，这种组合使得分析者难以分辨`condition`的真实作用。

举几个例子：

如果我们想执行A，可以将PT放到if的判断里，由于PT的值恒true，运行的时候只会执行A，不可能执行B。但是对于攻击者而言，他无法判断PT的值，所以他会觉得B也是有可能执行的。

```C++
if (PT) {
  A; // 执行A
} else {
  B; // 执行B
}
```

PF的值恒为false，所以不可能执行C，这个分支毫无意义，但是对于攻击者而言，他无法判断PF的值，所以会消耗成本去分析这个假分支。

```C++
if (PF) {
	C; // 执行C
}
```



#### 控制流混淆：插入无效代码

**死代码（Dead Code）插入**

- **目的**：侧重于数据混淆，通过修改或操作不会影响程序最终结果的“死”变量或寄存器，使得分析者难以区分哪些数据操作是真正有用的。

- **示例**：

  ```cpp
  int f() {
      int x, y;
      x = 1;
      
      // 下面的代码是死代码，因为x的值在被使用前会被重新赋值
      x = x + 2; 
      
      // y从未被使用，属于死代码
      y = 2;
      
      // 在此之前，x的初始值未被使用，是"死"的，但此处赋值后变为"活"
      x = 3;
      
      return x;
  }
  ```

**垃圾代码（Junk Code）插入**

- **目的**：侧重于控制流混淆，通过在永远不会执行到的程序分支中插入大量无用代码，使得控制流显得更加复杂，增加分析难度。

- **实现**：混淆器识别出程序中的无用分支（例如，基于不透明谓词的总是为真或为假的分支），并在这些分支内填充大量看似执行逻辑但实际无效的代码。

- **注意**：与死代码相比，垃圾代码强调的是其位于不可达的代码路径上，因此即便其操作了“活”的变量或寄存器，也不会影响程序的正常执行。



#### 控制流混淆：控制流间接化

控制流间接化是混淆技术中一种高级策略，它通过动态计算分支和调用目标地址，以及模拟处理器指令，使得控制流分析更加困难。

**JMP指令间接化**

将直接跳转指令（如`JMP <目标地址>`）间接化，可以使用以下模式：

```assembly
PUSH <目标地址>
RET
```

这种间接跳转方式通过将目标地址压栈，然后执行`RET`指令（相当于弹出栈顶内容至EIP寄存器），实现了跳转。这种方式使得静态分析时难以直接确定跳转目标，因为目标地址是在运行时计算和压栈的。

**CALL指令间接化及其扩展**

对于`CALL <目标地址>`指令，可以通过以下模式进行间接化，并在目标地址处进行相应处理以保持控制流的完整性：

```assembly
地址x: CALL <目标地址>
地址x+5: <垃圾代码>   ; 可选，进一步混淆
...
目标地址: ADD ESP, 4    ; 清除CALL压入的返回地址
; 接下来是实际的函数代码
```

此间接化方式同样隐藏了直接调用关系，`CALL`指令通过栈传递目标地址，到达目标函数后首先清理栈顶的返回地址（通常`CALL`指令会自动压入返回地址到栈上），然后继续执行函数代码。

**更改返回地址与模拟返回流程**

在某些混淆场景中，为了进一步混淆控制流，会修改函数的返回流程，例如：

```assembly
CALL <函数A>
原始返回地址: <垃圾代码>   ; 可能包含误导性指令
...
实际返回地址: NOP         ; 或其他不影响EIP移动的指令
...
```

在`函数A`结束时，为了返回到正确的地址，可能需要特殊处理：

```assembly
函数A起始地址: ADD [ESP], 9   ; 假设ESP当前指向返回地址上方9字节的位置，此操作实际上是跳过了垃圾代码
RET
```

这种技巧通过修改栈上的返回地址（通常是向上或向下调整栈指针），使得执行流绕过混淆插入的“垃圾代码”部分，直接跳转到实际的返回点，从而保证程序的正确执行，同时也极大地混淆了分析者对控制流的理解。

通过这些间接化和模拟技术，控制流混淆极大地增加了逆向工程的难度，不仅使得静态分析工具难以准确识别代码结构，也使得手动分析更加复杂和耗时。不过，这类混淆手段需要仔细设计以避免对性能造成过大影响，并确保程序的正确性。



#### 控制流混淆：控制流图扁平化

将程序原有的多层嵌套控制结构（如条件分支、循环等）打散并重新组织，通过一个中心分发器来控制程序的执行流程。将本来的代码分成几个基本的块，然后通过中心分发器来连接这些基本块；基本块之间的关系被隐藏在基本块之中。

举个例子：

```C++
int a,b;
a=1; b=2;
while(a<10){
    b=a+b;
    if(b>10)
b--; a++;
} 
use(b);
```

画出上面这个控制流图，为：
![截屏2024-06-13 02.42.35](https://p.ipic.vip/db8rbp.png)

通过switch这个中心分发器，我们可以将上面的程序更改为：

```C++
int a, b, swVar;
    start:
    switch(swVar){
        case 1:
            a = 1; b = 2;
            swVar = 2;
            goto start;
        case 2:
            if (a < 10){
                swVar = 3;
            } else {
                swVar = 6;
            }
            goto start;
        case 3:
            b = b + a;
            if (b > 10){
                swVar = 5;
            } else {
                swVar = 4;
            }
            goto start;
        case 4:
            b --;
            swVar = 5;
            goto start;
        case 5:
            a ++;
            swVar = 2;
            goto start;
        case 6:
            use(b);
    }
```

控制流图为：

![截屏2024-06-13 02.43.46](https://p.ipic.vip/92ffza.png)





























